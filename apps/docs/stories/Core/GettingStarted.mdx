import { Meta } from '@storybook/blocks';

<Meta title="Core/Getting Started" />

# Getting Started with semver-features

Learn how to use the core `semver-features` library in your application.

## Installation

```bash
# Using npm
npm install semver-features

# Using yarn
yarn add semver-features

# Using pnpm
pnpm add semver-features
```

## Basic Usage

### Initializing the Feature Manager

```js
import { SemverFeatures } from 'semver-features';

// Create a feature manager with the current version
const features = new SemverFeatures({ 
  version: '1.2.0',
  // Optional: custom options
  defaultDisabledValue: null,
  logger: console
});
```

### Registering Features

```js
// Register features with version requirements
const basicFeature = features.register('basic-feature', '1.0.0');
const newFeature = features.register('new-feature', '1.2.0');
const futureFeature = features.register('future-feature', '1.5.0');

// Register with custom options
const customFeature = features.register('custom-feature', '1.1.0', {
  defaultDisabledValue: 'fallback-value',
  logger: customLogger
});
```

### Checking Feature Status

```js
// Simple boolean check
if (basicFeature.isEnabled()) {
  // Feature is enabled
} else {
  // Feature is disabled
}

// With fallback values
const value = newFeature.getValue('default-value');
// Returns feature value if enabled, or 'default-value' if disabled
```

### Conditional Logic

```js
// Execute different code paths based on feature status
basicFeature.execute({
  enabled: () => {
    // Code when feature is enabled
    return 'Feature enabled result';
  },
  disabled: () => {
    // Code when feature is disabled
    return 'Feature disabled result';
  }
});

// Map to different values
const result = newFeature.map({
  enabled: 'enabled-value',
  disabled: 'disabled-value'
});

// Fold pattern (similar to execute but with simpler syntax)
const computedValue = futureFeature.fold(
  () => 'enabled-computed-value',
  () => 'disabled-computed-value'
);
```

## Advanced Usage

### Feature Compositions

```js
import { compose } from 'semver-features';

// Combine features with AND logic
const combinedFeature = compose.and([featureA, featureB, featureC]);

// Combine features with OR logic
const anyFeature = compose.or([featureA, featureB, featureC]);

// Create a negated feature
const notFeature = compose.not(featureA);
```

### Custom Evaluators

```js
// Create a feature with a custom evaluation function
const customFeature = features.registerWithEvaluator(
  'custom-logic-feature',
  (version, featureName) => {
    // Custom logic to determine if feature is enabled
    return someCondition && version >= '1.3.0';
  }
);
```

## Best Practices

1. **Use meaningful feature names** - Make feature names descriptive and consistent
2. **Version requirements** - Follow SemVer conventions for version requirements
3. **Feature compositions** - Use compositions for complex feature logic
4. **Error handling** - Consider what happens when features are disabled
5. **Testing** - Test both enabled and disabled feature paths

## Next Steps

- [API Documentation](/?path=/docs/api-core--docs)
- [Examples](/?path=/docs/examples-core--docs)
- [React Integration](/?path=/docs/react-getting-started--docs) 